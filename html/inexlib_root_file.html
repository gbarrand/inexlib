<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>histos and ntuples in a CERN-ROOT file</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">histos and ntuples in a CERN-ROOT file </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>With the inlib/wroot classes you can write histograms and ntuples in a file at the CERN-ROOT format. Here an "ntuple" is understood as a "flat TTree". With inlib/rroot classes you can read this kind of file. And if the zip compression is used, the exlib/rroot code permits to read "zip compressed" files. You can have a writing example with : </p><pre class="fragment">    cd &lt;path to inlib&gt;
    cd examples/cpp
    c++ -I../.. wroot.cpp
    ./a.out
</pre><p> The program produces the wroot.root file that you can read with : </p><pre class="fragment">    &lt;source setup CERN-ROOT&gt;  # in order to have root in your PATH.
    root ../../../exlib/examples/cern_root/rroot.C
</pre><p> You should see something as : </p><div class="image">
<img src="inlib_exa_rroot_C.png" alt="inlib_exa_rroot_C.png"/>
</div>
<p> You can also dump the list of "TKeys" of wroot.root by using the exlib/example/cpp/rroot.cpp program : </p><pre class="fragment">    cd &lt;path to exlib&gt;
    cd examples/cpp
    ./build rroot.cpp
    Linux&gt; ./bin_gnu/rroot -ls ../../../inlib/examples/cpp/wroot.root
</pre><p> You should see something as : </p><pre class="fragment">format version 40000
object : "rg_rbw", class : TTree
object : "rg_rbw_2", class : TTree
object : "empty", class : TTree
directory : histo
 object : "rg", class : TH1D
 object : "rf", class : TH1F
 object : "prof", class : TProfile
</pre><h1><a class="anchor" id="inexlib_root_file_rpawdemo"></a>
The rpawdemo.cpp program</h1>
<p>The rpawdemo.cpp program permits to read and dump an histo from the pawdemo.root file that comes from the distribution. </p><pre class="fragment">    cd &lt;path to exlib&gt;
    cd examples/cpp
    ./build rpawdemo.cpp
    cp ../../data/pawdemo.root .
    Linux&gt; ./bin_gnu/rpawdemo
 ( Darwin&gt; ./bin_clan/rpawdemo )
 ( cygwin&gt; ./bin_visual/rpawdemo.exe )
</pre><p> You should see something as : </p><pre class="fragment">size of h10 : 900
1TEST1   
 * ENTRIES = 10000 * ALL CHANNELS = 7314 * UNDERFLOW = 14 * OVERFLOW = 14
 * BIN WID = 0.06 * MEAN VALUE = 0.00538966 * R . M . S = 1.1085
 * ENTRIES[0]   = 0 * HEIGHT[0] = 3 * ERROR[0] = 0
 * ENTRIES[N/2] = 0 * HEIGHT[N/2] = 127 * ERROR[N/2] = 0
 * ENTRIES[N-1] = 0 * HEIGHT[N-1] = 1 * ERROR[N-1] = 0
</pre> <pre class="fragment">// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file exlib.license for terms.

//exlib_build_use exlib inlib csz

#include &lt;inlib/mem&gt;

#include &lt;inlib/args&gt;
#include &lt;inlib/rroot/file&gt;
#include &lt;inlib/rroot/streamers&gt;

#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main(int argc,char** argv) {

#ifdef INLIB_MEM
  inlib::mem::set_check_by_class(true);{
#endif

  inlib::args args(argc,argv);

  bool verbose = args.is_arg("-verbose");

  std::string file = "pawdemo.root";
  inlib::rroot::file rfile(std::cout,file,verbose);

  inlib::rroot::key* key = rfile.dir().find_key("h10");
  if(!key) {
    std::cout &lt;&lt; "key for h10 not found." &lt;&lt; std::endl;
    return EXIT_FAILURE;
  }
  unsigned int sz;
  char* buf = key-&gt;get_object_buffer(rfile,sz);
  if(!buf) {
    std::cout &lt;&lt; "can't get data buffer for h10." &lt;&lt; std::endl;
    return EXIT_FAILURE;
  }
  std::cout &lt;&lt; "size of h10 : " &lt;&lt; sz &lt;&lt; std::endl;

  inlib::rroot::buffer b(std::cout,rfile.byte_swap(),sz,buf,key-&gt;key_length(),verbose);
  inlib::histo::h1d* h = inlib::rroot::TH1F_stream(b); //we get ownership on h.
  if(!h) {
    std::cout &lt;&lt; "streaming failed for h10." &lt;&lt; std::endl;
    return EXIT_FAILURE;
  }

  h-&gt;hprint(std::cout);

  delete h;
  
#ifdef INLIB_MEM
  }inlib::mem::balance(std::cout);
#endif

  return EXIT_SUCCESS;
}
</pre><h1><a class="anchor" id="inexlib_root_file_wroot"></a>
The wroot.cpp program</h1>
<pre class="fragment">// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

//  This program produces a wroot.root file.
//
//  See rroot.C for an example of how to manipulate
// (and check !) the content of this file with CERN-ROOT.

//inlib_build_use kernel

#ifndef EXLIB_DONT_HAVE_ZLIB
#define EXLIB_DONT_HAVE_ZLIB
#endif

#ifdef INLIB_MEM
#include &lt;inlib/mem&gt;
#endif //INLIB_MEM

#include &lt;inlib/wroot/file&gt;
#include &lt;inlib/wroot/to&gt;

#include &lt;inlib/histo/h1d&gt;
#include &lt;inlib/histo/h2d&gt;
#include &lt;inlib/histo/h3d&gt;
#include &lt;inlib/histo/p1d&gt;
#include &lt;inlib/histo/p2d&gt;
#include &lt;inlib/wroot/ntuple&gt;

#include &lt;inlib/histo/h1df&gt;

#include &lt;inlib/randd&gt;
#include &lt;inlib/randf&gt;

#include &lt;inlib/rroot/file&gt;
#include &lt;inlib/rroot/ntuple&gt;
#include &lt;inlib/rroot/fac&gt;
#include &lt;inlib/eqT&gt;

#ifdef EXLIB_DONT_HAVE_ZLIB
#else
#include &lt;exlib/zlib&gt;
#endif

#include &lt;inlib/args&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main(int argc,char** argv) {

#ifdef INLIB_MEM
  inlib::mem::set_check_by_class(true);{
#endif //INLIB_MEM
  inlib::args args(argc,argv);

  bool verbose = args.is_arg("-verbose");

  bool row_wise = args.is_arg("-row_wise");
  
  //////////////////////////////////////////////////////////
  /// create a .root file : ////////////////////////////////
  //////////////////////////////////////////////////////////
  if(verbose) std::cout &lt;&lt; (row_wise?"row_wise":"column_wise") &lt;&lt; std::endl;
  
  std::string file = "wroot.root";
  
 {inlib::wroot::file rfile(std::cout,file);
#ifdef EXLIB_DONT_HAVE_ZLIB
#else
  if(args.is_arg("-noz")){
  } else {
    rfile.add_ziper('Z',exlib::compress_buffer);
    rfile.set_compression(9);
  }
#endif

  bool osc_stream = args.is_arg("-osc");

  inlib::wroot::directory* dir = rfile.dir().mkdir("histo");
  if(!dir) {
    std::cout &lt;&lt; "can't create diectory." &lt;&lt; std::endl;
    return EXIT_FAILURE;
  }

  //inlib::wroot::directory* dxxx = dir-&gt;mkdir("xxx");
  //if(!dxxx) {
  //  std::cout &lt;&lt; "can't create diectory." &lt;&lt; std::endl;
  //  return EXIT_FAILURE;
  //}

  //////////////////////////////////////////////////////////
  /// create some histos : /////////////////////////////////
  //////////////////////////////////////////////////////////

  unsigned int num_megas;
  args.find&lt;unsigned int&gt;("-megas",num_megas,1);

  unsigned int entries = num_megas*1000000;

  inlib::rgaussd rg(1,2);
  inlib::rbwd rbw(0,1);

 {inlib::histo::h1d h("Gauss",100,-5,5);
  for(unsigned int count=0;count&lt;entries;count++) h.fill(rg.shoot(),1.4);
  // plotting hints :
  h.add_annotation(inlib::histo::key_axis_x_title(),"rand gauss");
  h.add_annotation(inlib::histo::key_axis_y_title(),"1.4*entries");
  if(verbose) {
    std::cout &lt;&lt; "h1d : " &lt;&lt; h.title()
              &lt;&lt; ", all entries " &lt;&lt; h.all_entries()
              &lt;&lt; ", entries " &lt;&lt; h.entries()
              &lt;&lt; ", mean " &lt;&lt; h.mean() &lt;&lt; ", rms " &lt;&lt; h.rms()
              &lt;&lt; std::endl;
  }
  // write :
  if(osc_stream) {
    if(!inlib::wroot::to_osc(*dir,h,"rg")) return EXIT_FAILURE;
  } else {
    if(!inlib::wroot::to(*dir,h,"rg")) return EXIT_FAILURE;
  }}

 {inlib::rgaussf rf(1,2);
  inlib::histo::h1df h("GaussF",100,-5,5);
  for(unsigned int count=0;count&lt;entries;count++) h.fill(rf.shoot(),1.4f);
  // plotting hints :
  h.add_annotation(inlib::histo::key_axis_x_title(),"rand gauss");
  h.add_annotation(inlib::histo::key_axis_y_title(),"1.4*entries");
  if(verbose) {
    std::cout &lt;&lt; "h1df : " &lt;&lt; h.title()
              &lt;&lt; ", all entries " &lt;&lt; h.all_entries()
              &lt;&lt; ", entries " &lt;&lt; h.entries()
              &lt;&lt; ", mean " &lt;&lt; h.mean() &lt;&lt; ", rms " &lt;&lt; h.rms()
              &lt;&lt; std::endl;
  }
  // write :
  if(!inlib::wroot::to(*dir,h,"rf")) return EXIT_FAILURE;}

 {inlib::histo::p1d h("Profile",100,-5,5,-2,2);
  for(unsigned int count=0;count&lt;entries;count++) h.fill(rg.shoot(),rbw.shoot(),1);
  if(verbose) {
    std::cout &lt;&lt; "p1d : " &lt;&lt; h.title()
              &lt;&lt; ", all entries " &lt;&lt; h.all_entries()
              &lt;&lt; ", entries " &lt;&lt; h.entries()
              &lt;&lt; ", mean " &lt;&lt; h.mean() &lt;&lt; ", rms " &lt;&lt; h.rms()
              &lt;&lt; std::endl;
  }
  if(osc_stream) {
    if(!inlib::wroot::to_osc(*dir,h,"prof")) return EXIT_FAILURE;
  } else {
    if(!inlib::wroot::to(*dir,h,"prof")) return EXIT_FAILURE;
  }}

 {inlib::histo::h2d h("Gauss_BW",20,-5,5,20,-2,2);
  for(unsigned int count=0;count&lt;entries;count++) h.fill(rg.shoot(),rbw.shoot(),0.8);
  //plotting hints :
  h.add_annotation(inlib::histo::key_axis_x_title(),"rand gauss");
  h.add_annotation(inlib::histo::key_axis_y_title(),"rand bw");
  h.add_annotation(inlib::histo::key_axis_z_title(),"0.8*entries");
  if(verbose) {
    std::cout &lt;&lt; "h2d : " &lt;&lt; h.title()
              &lt;&lt; ", all entries " &lt;&lt; h.all_entries()
              &lt;&lt; ", entries " &lt;&lt; h.entries()
              &lt;&lt; ", mean_x " &lt;&lt; h.mean_x() &lt;&lt; ", rms_x " &lt;&lt; h.rms_x()
              &lt;&lt; ", mean_y " &lt;&lt; h.mean_y() &lt;&lt; ", rms_y " &lt;&lt; h.rms_y()
              &lt;&lt; std::endl;
  }
  // write :
  if(osc_stream) {
    if(!inlib::wroot::to_osc(*dir,h,"rgbw")) return EXIT_FAILURE;
  } else {
    if(!inlib::wroot::to(*dir,h,"rgbw")) return EXIT_FAILURE;
  }}

 {inlib::histo::p2d h("Profile2D",100,-5,5,100,-5,5,-2,2);
  for(unsigned int count=0;count&lt;entries;count++) h.fill(rg.shoot(),rg.shoot(),rbw.shoot(),1);
  if(verbose) {
    std::cout &lt;&lt; "p2d : " &lt;&lt; h.title()
              &lt;&lt; ", all entries " &lt;&lt; h.all_entries()
              &lt;&lt; ", entries " &lt;&lt; h.entries()
              &lt;&lt; ", mean_x " &lt;&lt; h.mean_x() &lt;&lt; ", rms_x " &lt;&lt; h.rms_x()
              &lt;&lt; ", mean_y " &lt;&lt; h.mean_y() &lt;&lt; ", rms_y " &lt;&lt; h.rms_y()
              &lt;&lt; std::endl;
  }
  if(osc_stream) {
    if(!inlib::wroot::to_osc(*dir,h,"prof2D")) return EXIT_FAILURE;
  } else {
    if(!inlib::wroot::to(*dir,h,"prof2D")) return EXIT_FAILURE;
  }}

 {inlib::histo::h3d h("Gauss_Gauss_BW",20,-5,5,20,-5,5,20,-2,2);
  for(unsigned int count=0;count&lt;entries;count++) h.fill(rg.shoot(),rg.shoot(),rbw.shoot(),0.8);
  //plotting hints :
  h.add_annotation(inlib::histo::key_axis_x_title(),"rand gauss");
  h.add_annotation(inlib::histo::key_axis_y_title(),"rand gauss");
  h.add_annotation(inlib::histo::key_axis_z_title(),"rand bw");
  if(verbose) {
    std::cout &lt;&lt; "h3d : " &lt;&lt; h.title()
              &lt;&lt; ", all entries " &lt;&lt; h.all_entries()
              &lt;&lt; ", entries " &lt;&lt; h.entries()
              &lt;&lt; ", mean_x " &lt;&lt; h.mean_x() &lt;&lt; ", rms_x " &lt;&lt; h.rms_x()
              &lt;&lt; ", mean_y " &lt;&lt; h.mean_y() &lt;&lt; ", rms_y " &lt;&lt; h.rms_y()
              &lt;&lt; ", mean_z " &lt;&lt; h.mean_z() &lt;&lt; ", rms_z " &lt;&lt; h.rms_z()
              &lt;&lt; std::endl;
  }
  // write :
  if(osc_stream) {
    if(!inlib::wroot::to_osc(*dir,h,"rggbw")) return EXIT_FAILURE;
  } else {
    if(!inlib::wroot::to(*dir,h,"rggbw")) return EXIT_FAILURE;
  }}

  //////////////////////////////////////////////////////////
  /// create and fill a ntuple : ///////////////////////////
  //////////////////////////////////////////////////////////
 {//WARNING : the ntuple can't be on the stack. It is owned by the directory.
  inlib::wroot::ntuple* ntu = new inlib::wroot::ntuple(rfile.dir(),"rg_rbw","Randoms",row_wise);
  inlib::wroot::ntuple::column&lt;int&gt;* col_count = ntu-&gt;create_column&lt;int&gt;("count");
  inlib::wroot::ntuple::column&lt;double&gt;* col_rgauss = ntu-&gt;create_column&lt;double&gt;("rgauss");
  inlib::wroot::ntuple::column&lt;float&gt;* col_rbw = ntu-&gt;create_column&lt;float&gt;("rbw");
  inlib::wroot::ntuple::column_string* col_str = ntu-&gt;create_column_string("string");

  std::vector&lt;float&gt; user_vec_f;
  ntu-&gt;create_column_vector_ref&lt;float&gt;("vec_float",user_vec_f); //pass the ref of user_vec_f.
  inlib::wroot::ntuple::std_vector_column&lt;double&gt;* col_vec_d = ntu-&gt;create_column_vector&lt;double&gt;("vec_d");
  std::vector&lt;std::string&gt; user_vec_s;
  ntu-&gt;create_column_vector_string_ref("vec_s",user_vec_s,'\n');
  
  if(args.is_arg("-large")){
    entries = 300000000; //to test &gt;2Gbytes file.
    ntu-&gt;set_basket_size(1000000);
  }

  inlib::rtausmed rflat;
  unsigned int vec_float_count = 0;
  unsigned int vec_double_count = 0;
  
  inlib::rbwf rbwf(0,1);
  std::string stmp;
  for(unsigned int count=0;count&lt;entries;count++) {    
    if(!col_count-&gt;fill(count)) {
      std::cout &lt;&lt; "col_count fill failed." &lt;&lt; std::endl;
      break;
    }
    if(!col_rgauss-&gt;fill(rg.shoot())) {
      std::cout &lt;&lt; "col_rgauss fill failed." &lt;&lt; std::endl;
      break;
    }
    if(!col_rbw-&gt;fill(rbwf.shoot())) {
      std::cout &lt;&lt; "col_rbw fill failed." &lt;&lt; std::endl;
      break;
    }
    if(!inlib::num2s(count,stmp)){}
    if(!col_str-&gt;fill("str "+stmp)) {
      std::cout &lt;&lt; "col_str fill failed." &lt;&lt; std::endl;
      break;
    }

   {user_vec_f.clear();
    unsigned int number = (unsigned int)(10*rflat.shoot());
    for(unsigned int i=0;i&lt;number;i++) {
      user_vec_f.push_back(rbwf.shoot());
    }
    vec_float_count += number;}

   {std::vector&lt;double&gt;&amp; user_vec_d = col_vec_d-&gt;variable();
    user_vec_d.clear();
    unsigned int number = row_wise ? count%100 : (unsigned int)(10*rflat.shoot());
    for(unsigned int i=0;i&lt;number;i++) {
      user_vec_d.push_back(rg.shoot());
    }
    vec_double_count += number;}

   {user_vec_s.clear();
    unsigned int number = row_wise ? count%5 : (unsigned int)(5*rflat.shoot());
    for(unsigned int i=0;i&lt;number;i++) {
      if(!inlib::num2s(i,stmp)){}
      user_vec_s.push_back(stmp);
    }}
     
    if(!ntu-&gt;add_row()) {
      std::cout &lt;&lt; "ntuple fill failed." &lt;&lt; std::endl;
      break;
    }
  }
  if(verbose) {
    std::cout &lt;&lt; "vec_float_count " &lt;&lt; vec_float_count &lt;&lt; std::endl;
    std::cout &lt;&lt; "vec_double_count " &lt;&lt; vec_double_count &lt;&lt; std::endl;
  }}
  
  //////////////////////////////////////////////////////////
  /// create a ntuple from a ntuple_booking object. ////////
  //////////////////////////////////////////////////////////
 {inlib::ntuple_booking nbk("rg_rbw_2","Randoms");
  nbk.add_column&lt;double&gt;("rgauss");
  nbk.add_column&lt;float&gt;("rbw");
  nbk.add_column&lt;std::string&gt;("string");
  //nbk.add_column&lt;bool&gt;("not_handled");

  inlib::wroot::ntuple* ntu = new inlib::wroot::ntuple(rfile.dir(),nbk);
  if(ntu-&gt;columns().size()) {

    inlib::wroot::ntuple::column&lt;double&gt;* col_rgauss = ntu-&gt;find_column&lt;double&gt;("rgauss");
    inlib::wroot::ntuple::column&lt;float&gt;* col_rbw = ntu-&gt;find_column&lt;float&gt;("rbw");
    inlib::wroot::ntuple::column_string* col_str = ntu-&gt;find_column_string("string");

    inlib::rbwf rbwf(0,1);
    std::string stmp;
    for(unsigned int count=0;count&lt;1000;count++) {    
      if(!col_rgauss-&gt;fill(rg.shoot())) {
        std::cout &lt;&lt; "col_rgauss fill failed." &lt;&lt; std::endl;
        break;
      }
      if(!col_rbw-&gt;fill(rbwf.shoot())) {
        std::cout &lt;&lt; "col_rbw fill failed." &lt;&lt; std::endl;
        break;
      }
      if(!inlib::num2s(count,stmp)){}
      if(!col_str-&gt;fill("str "+stmp)) {
        std::cout &lt;&lt; "col_str fill failed." &lt;&lt; std::endl;
        break;
      }
      if(!ntu-&gt;add_row()) {
        std::cout &lt;&lt; "ntuple fill failed." &lt;&lt; std::endl;
        break;
      }
    }
  }}

  //////////////////////////////////////////////////////////
  /// consistency check : create an empty ntuple : /////////
  //////////////////////////////////////////////////////////
 {inlib::wroot::ntuple* ntu = new inlib::wroot::ntuple(rfile.dir(),"empty","empty");
  ntu-&gt;create_column&lt;int&gt;("empty");}

  //////////////////////////////////////////////////////////
  /// write and close file : ///////////////////////////////
  //////////////////////////////////////////////////////////
 {unsigned int n;
  if(!rfile.write(n)) {
    std::cout &lt;&lt; "file write failed." &lt;&lt; std::endl;
  }}
  
  rfile.close();}

  //////////////////////////////////////////////////////////
  /// read the file : //////////////////////////////////////
  //////////////////////////////////////////////////////////
 
#include "read_root.icc"
  //////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////

#ifdef INLIB_MEM
  }inlib::mem::balance(std::cout);
#endif //INLIB_MEM

  return EXIT_SUCCESS;
}
</pre><h1><a class="anchor" id="inexlib_root_file_rroot"></a>
The rroot.cpp program</h1>
<pre class="fragment">// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file exlib.license for terms.

//exlib_build_use exlib inlib csz zlib

#ifdef INLIB_MEM
#include &lt;inlib/mem&gt;
#endif //INLIB_MEM

#include &lt;inlib/args&gt;
#include &lt;inlib/fileis&gt;

#include &lt;inlib/rroot/file&gt;
#include &lt;inlib/rroot/rall&gt;

#include &lt;inlib/rroot/ntuple&gt;
#include &lt;inlib/ntuple_binding&gt;

#ifdef EXLIB_DONT_HAVE_ZLIB
#else
#include &lt;exlib/zlib&gt;
#endif

#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main(int argc,char** argv) {

#ifdef INLIB_MEM
  inlib::mem::set_check_by_class(true);{
#endif //INLIB_MEM

  inlib::args args(argc,argv);

  std::string file;
  if(!args.file(file)) {
    std::cout &lt;&lt; "give a root file." &lt;&lt; std::endl;
    return EXIT_FAILURE;
  }

  bool verbose = args.is_arg("-verbose");
  bool ls = args.is_arg("-ls");
  bool dump = args.is_arg("-dump");

 {bool is;
  inlib::file::is_root(file,is);
  if(!is) {
    std::cout &lt;&lt; " file is not a root file." &lt;&lt; std::endl;
    return EXIT_FAILURE;
  }}

  inlib::rroot::file rfile(std::cout,file,verbose);
#ifdef EXLIB_DONT_HAVE_ZLIB
#else
  rfile.add_unziper('Z',exlib::decompress_buffer);
#endif

  if(ls) {
    std::cout &lt;&lt; "format version " &lt;&lt; rfile.version() &lt;&lt; std::endl;
  }
      
  const std::vector&lt;inlib::rroot::key*&gt;&amp; keys = rfile.dir().keys();
  inlib::rroot::read(std::cout,rfile,keys,true,ls,dump,0);

  ///////////////////////////////////////////////////////////////
  /// if reading the wroot.root produced with wroot.cpp : ///////
  ///////////////////////////////////////////////////////////////
 {inlib::rroot::TDirectory* dir = inlib::rroot::find_dir(rfile.dir(),"histo");
  if(dir) {
   {inlib::rroot::key* key = dir-&gt;find_key("rg");
    if(key) {
      inlib::histo::h1d* h = inlib::rroot::key_to_h1d(rfile,*key);
      if(h) {
        std::cout &lt;&lt; "h1d : " &lt;&lt; h-&gt;title()
                  &lt;&lt; ", all_entries " &lt;&lt; h-&gt;all_entries()
                  &lt;&lt; ", entries " &lt;&lt; h-&gt;entries()
                  &lt;&lt; ", mean " &lt;&lt; h-&gt;mean() &lt;&lt; ", rms " &lt;&lt; h-&gt;rms()
                  &lt;&lt; std::endl;
        delete h;
      }
    }}
   {inlib::rroot::key* key = dir-&gt;find_key("rf");
    if(key) {
      inlib::histo::h1d* h = inlib::rroot::key_to_h1d(rfile,*key);
      if(h) {
        std::cout &lt;&lt; "h1d : " &lt;&lt; h-&gt;title()
                  &lt;&lt; ", all_entries " &lt;&lt; h-&gt;all_entries()
                  &lt;&lt; ", entries " &lt;&lt; h-&gt;entries()
                  &lt;&lt; ", mean " &lt;&lt; h-&gt;mean() &lt;&lt; ", rms " &lt;&lt; h-&gt;rms()
                  &lt;&lt; std::endl;
        delete h;
      }
    }}
   {inlib::rroot::key* key = dir-&gt;find_key("rgbw");
    if(key) {
      inlib::histo::h2d* h = inlib::rroot::key_to_h2d(rfile,*key);
      if(h) {
        std::cout &lt;&lt; "h2d : " &lt;&lt; h-&gt;title()
                  &lt;&lt; ", all_entries " &lt;&lt; h-&gt;all_entries()
                  &lt;&lt; ", entries " &lt;&lt; h-&gt;entries()
                  &lt;&lt; ", mean_x " &lt;&lt; h-&gt;mean_x() &lt;&lt; ", rms_x " &lt;&lt; h-&gt;rms_x()
                  &lt;&lt; ", mean_y " &lt;&lt; h-&gt;mean_y() &lt;&lt; ", rms_y " &lt;&lt; h-&gt;rms_y()
                  &lt;&lt; std::endl;
        delete h;
      }
    }}
   {inlib::rroot::key* key = dir-&gt;find_key("prof");
    if(key) {
      inlib::histo::p1d* h = inlib::rroot::key_to_p1d(rfile,*key);
      if(h) {
        std::cout &lt;&lt; "p1d : " &lt;&lt; h-&gt;title()
                  &lt;&lt; ", all_entries " &lt;&lt; h-&gt;all_entries()
                  &lt;&lt; ", entries " &lt;&lt; h-&gt;entries()
                  &lt;&lt; ", mean " &lt;&lt; h-&gt;mean() &lt;&lt; ", rms " &lt;&lt; h-&gt;rms()
                  &lt;&lt; std::endl;
        delete h;
      }
    }}
   {inlib::rroot::key* key = dir-&gt;find_key("prof2D");
    if(key) {
      inlib::histo::p2d* h = inlib::rroot::key_to_p2d(rfile,*key);
      if(h) {
        std::cout &lt;&lt; "p2d : " &lt;&lt; h-&gt;title()
                  &lt;&lt; ", all_entries " &lt;&lt; h-&gt;all_entries()
                  &lt;&lt; ", entries " &lt;&lt; h-&gt;entries()
                  &lt;&lt; ", mean_x " &lt;&lt; h-&gt;mean_x() &lt;&lt; ", rms_x " &lt;&lt; h-&gt;rms_x()
                  &lt;&lt; ", mean_y " &lt;&lt; h-&gt;mean_y() &lt;&lt; ", rms_y " &lt;&lt; h-&gt;rms_y()
                  &lt;&lt; std::endl;
        delete h;
      }
    }}
   {inlib::rroot::key* key = dir-&gt;find_key("rggbw");
    if(key) {
      inlib::histo::h3d* h = inlib::rroot::key_to_h3d(rfile,*key);
      if(h) {
        std::cout &lt;&lt; "h3d : " &lt;&lt; h-&gt;title()
                  &lt;&lt; ", all_entries " &lt;&lt; h-&gt;all_entries()
                  &lt;&lt; ", entries " &lt;&lt; h-&gt;entries()
                  &lt;&lt; ", mean_x " &lt;&lt; h-&gt;mean_x() &lt;&lt; ", rms_x " &lt;&lt; h-&gt;rms_x()
                  &lt;&lt; ", mean_y " &lt;&lt; h-&gt;mean_y() &lt;&lt; ", rms_y " &lt;&lt; h-&gt;rms_y()
                  &lt;&lt; ", mean_z " &lt;&lt; h-&gt;mean_z() &lt;&lt; ", rms_z " &lt;&lt; h-&gt;rms_z()
                  &lt;&lt; std::endl;
        delete h;
      }
    }}
    delete dir; 
  }}
 
  ////////////////////////////////////////////////////////////////////////////////////////
  // read an ntuple from inlib/examples/cpp/wroot.cpp, wroot_pntuple.cpp, pwroot.cpp : ///
  ////////////////////////////////////////////////////////////////////////////////////////
 {inlib::rroot::key* key = rfile.dir().find_key("rg_rbw");
  if(key) {
    unsigned int sz;
    char* buf = key-&gt;get_object_buffer(rfile,sz);
    if(!buf) {
      std::cout &lt;&lt; "can't get data buffer for ntuple." &lt;&lt; std::endl;
      return EXIT_FAILURE;
    }
    inlib::rroot::buffer b(std::cout,rfile.byte_swap(),sz,buf,key-&gt;key_length(),verbose);
    inlib::rroot::fac fac(std::cout);
    inlib::rroot::tree tree(rfile,fac);
    if(!tree.stream(b)) {
      std::cout &lt;&lt; "TTree streaming failed." &lt;&lt; std::endl;
      return EXIT_FAILURE;
    }
    tree.dump(std::cout,"","  ");
    //inlib::uint64 entries = tree.entries();
   {for(inlib::uint32 i=0;i&lt;5;i++){
      if(!tree.show(std::cout,i)) {
        std::cout &lt;&lt; "show failed for entry " &lt;&lt; i &lt;&lt; std::endl;
        return EXIT_FAILURE;
      }
    }}
   {inlib::uint64 entries = tree.entries();  
    for(inlib::uint64 i=inlib::mx&lt;inlib::int64&gt;(5,entries-5);i&lt;entries;i++){
      if(!tree.show(std::cout,(inlib::uint32)i)) {
        std::cout &lt;&lt; "show failed for entry " &lt;&lt; i &lt;&lt; std::endl;
        return EXIT_FAILURE;
      }
    }}

    // read with the flat ntuple API :
   {inlib::rroot::ntuple ntu(tree); //use the flat ntuple API.
    double user_rgauss;
    std::string user_string;
    
    inlib::ntuple_binding nbd;
    nbd.add_column("rgauss",user_rgauss);
    nbd.add_column("string",user_string);
    if(!ntu.initialize(std::cout,nbd)) {
      std::cout &lt;&lt; "can't initialize ntuple with ntuple_binding." &lt;&lt; std::endl;
      return EXIT_FAILURE;
    }
    inlib::histo::h1d hg("rgauss",100,-5,5);
    ntu.start();
    unsigned int count = 0;
    while(ntu.next()){
      if(!ntu.get_row()) {
        std::cout &lt;&lt; "get_row() failed." &lt;&lt; std::endl;
        return EXIT_FAILURE;
      }
      hg.fill(user_rgauss);
      if(count&lt;5) std::cout &lt;&lt; "user_string " &lt;&lt; user_string &lt;&lt; std::endl;
      count++;
    }
    std::cout &lt;&lt; "ntuple_binding(rgauss) : " &lt;&lt; hg.mean() &lt;&lt; " " &lt;&lt; hg.rms() &lt;&lt; std::endl;}

  }}

  ///////////////////////////////////////////////////////////////
  /// if reading the pawdemo.root : /////////////////////////////
  ///////////////////////////////////////////////////////////////
 {inlib::rroot::key* key = rfile.dir().find_key("h10");
  if(key) {
    inlib::histo::h1d* h = inlib::rroot::key_to_h1d(rfile,*key);
    if(h) {
      std::cout &lt;&lt; "h1d : h10"
                &lt;&lt; ", all_entries " &lt;&lt; h-&gt;all_entries()
                &lt;&lt; ", entries " &lt;&lt; h-&gt;entries()
                &lt;&lt; ", mean " &lt;&lt; h-&gt;mean() &lt;&lt; ", rms " &lt;&lt; h-&gt;rms()
                &lt;&lt; std::endl;
      delete h;
    }
  }}

  /////////////////////////////////////////////////////////////////////
  /// if reading the prof.root produced with croot_TProfile.cpp : /////
  /////////////////////////////////////////////////////////////////////
 {inlib::rroot::key* key = rfile.dir().find_key("prof");
  if(key) {
    inlib::histo::p1d* h = inlib::rroot::key_to_p1d(rfile,*key);
    if(h) {
      std::cout &lt;&lt; "p1d : prof"
                &lt;&lt; ", all_entries " &lt;&lt; h-&gt;all_entries()
                &lt;&lt; ", entries " &lt;&lt; h-&gt;entries()
                &lt;&lt; ", mean " &lt;&lt; h-&gt;mean() &lt;&lt; ", rms " &lt;&lt; h-&gt;rms()
                &lt;&lt; std::endl;
      delete h;
    }
  }}
 {inlib::rroot::key* key = rfile.dir().find_key("prof2D");
  if(key) {
    inlib::histo::p2d* h = inlib::rroot::key_to_p2d(rfile,*key);
    if(h) {
      std::cout &lt;&lt; "p2d : prof"
                &lt;&lt; ", all_entries " &lt;&lt; h-&gt;all_entries()
                &lt;&lt; ", entries " &lt;&lt; h-&gt;entries()
                &lt;&lt; ", mean_x " &lt;&lt; h-&gt;mean_x() &lt;&lt; ", rms_x " &lt;&lt; h-&gt;rms_x()
                &lt;&lt; ", mean_y " &lt;&lt; h-&gt;mean_y() &lt;&lt; ", rms_y " &lt;&lt; h-&gt;rms_y()
                &lt;&lt; std::endl;
      delete h;
    }
  }}

#ifdef INLIB_MEM
  }inlib::mem::balance(std::cout);
#endif //INLIB_MEM

  return EXIT_SUCCESS;
}
</pre> </div></div><!-- contents -->

</body>
</html>
