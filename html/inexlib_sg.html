<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>inlib, exlib / sg</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">inlib, exlib / sg </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The inlib/exlib comes with a set of classes permitting to build "scene graphs" (sg) to do visualization with OpenGL-ES. It is well known that even visualizing a cube with OpenGL is tedious, and something on top of it is needed. You need some kind of "scene manager" with which you can easily specify : here I want a blue cube, here a rotated green cylinder, here I put a light and I want a camera at such position looking in this direction, etc... In the 1980's Silicon Graphics had created Open Inventor to do that. But for the moment there is no free Inventor implementation over OpenGL-ES only and available for iOS and Android. Then to move on with our applications, we have decided to create our own scene manager (inexlib/sg) fulfilling these specifications.</p>
<h1><a class="anchor" id="inexlib_sg_usage"></a>
Usage</h1>
<p>The way to use inexlib/sg is similar to Inventor. You create "nodes" that you combine in "scene graphs" by using node containers as the inlib/sg/separator one. When done you create a "exlib::sg::viewer" to which you declare your scene graph. Then you arrange to create a (X11, Cocoa, Windows, iOS or Android) window aware of OpenGL-ES and then at each "expose event" you arrange to execute the viewer.render() method.</p>
<h1><a class="anchor" id="inexlib_sg_cube"></a>
Visualizing a cube</h1>
<p>On a desktop, you can have an idea by building the exlib sg_cube_X11.cpp that visualizes a cube by using inexlib/sg : </p><pre class="fragment">    cd &lt;path to exlib&gt;
    cd examples/cpp
    ./build sg_cube_X11.cpp
    Linux&gt; ./bin_gnu/sg_cube_X11
</pre><p> You should see : </p><div class="image">
<img src="exlib_exa_sg_0.png" alt="exlib_exa_sg_0.png"/>
</div>
<p>You can have a look to sg_cube_X11.cpp and see that the code is rather simple and easy to customize... </p><pre class="fragment">// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file exlib.license for terms.

//exlib_build_use exlib inlib GL GLX X11

// should compile with : build -inlib_gl -x11_no_gl

#include &lt;inlib/mem&gt;

#include &lt;inlib/mathf&gt;
#include &lt;inlib/colorfs&gt;

#include &lt;inlib/sg/separator&gt;
#include &lt;inlib/sg/ortho&gt;
#include &lt;inlib/sg/matrix&gt;
#include &lt;inlib/sg/color&gt;
#include &lt;inlib/sg/cube&gt;

#ifdef EXLIB_NO_GL
#include &lt;exlib/X11/base_session&gt;
#include &lt;exlib/X11/viewer&gt;
#else
#include &lt;exlib/X11/session&gt;
#include &lt;exlib/sg/viewer&gt;
#endif

#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main(int,char**) {

#ifdef INLIB_MEM
  inlib::mem::set_check_by_class(true);{
#endif

  //////////////////////////////////////////////////////////
  /// create scene graph ///////////////////////////////////
  //////////////////////////////////////////////////////////
  inlib::sg::separator* sep = new inlib::sg::separator;

  inlib::sg::ortho* camera = new inlib::sg::ortho;
  camera-&gt;position.value(inlib::vec3f(0,0,4));    
  camera-&gt;height.value(2);    
  camera-&gt;znear.value(0.1);
  camera-&gt;zfar.value(100);
  sep-&gt;add(camera);

 {inlib::sg::matrix* m = new inlib::sg::matrix;
  m-&gt;set_rotate(0,1,0,inlib::fhalf_pi()/2.0f);
  m-&gt;mul_rotate(1,0,0,inlib::fhalf_pi()/2.0f);
  sep-&gt;add(m);} //done first.

  inlib::sg::color* color = new inlib::sg::color();
  color-&gt;rgb = inlib::colorf_green();
  sep-&gt;add(color); //sg takes ownership of color.

  inlib::sg::cube* node = new inlib::sg::cube();
  node-&gt;width.value(1.0f);
  node-&gt;height.value(1.0f);
  node-&gt;depth.value(1.0f);
  sep-&gt;add(node);

  //////////////////////////////////////////////////////////
  /// create window, attach to the viewer, steer ///////////
  //////////////////////////////////////////////////////////

#ifdef EXLIB_NO_GL
  exlib::X11::base_session x11(std::cout);
#else
  exlib::X11::session x11(std::cout);
#endif  
  if(!x11.display()) return EXIT_FAILURE;

  Window win = x11.create_window("win 1",0,0,400,200);
  if(win==0L) return EXIT_FAILURE;

  //////////////////////////////////////////////////////////
  /// create the viewer, set the scene graph ///////////////
  //////////////////////////////////////////////////////////
#ifdef EXLIB_NO_GL
  exlib::X11::viewer viewer(std::cout,x11.display(),win,400,200);
#else  
  exlib::sg::viewer viewer(std::cout,400,200);
#endif  
  viewer.sg().add(sep); //give sep ownership to the viewer.
  //////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////

  
  x11.show_window(win);

  Atom atom = ::XInternAtom(x11.display(),"WM_DELETE_WINDOW",False);

  while(true) { 
      XEvent xevent;
      ::XNextEvent(x11.display(),&amp;xevent);
      //std::cout &lt;&lt; xevent.type &lt;&lt; std::endl;
      //if((xevent.type==Expose)||(xevent.type==ConfigureNotify)) {
      if(xevent.type==ClientMessage) {
        if(xevent.xclient.data.l[0]==(long)atom) break;        
      } else if(xevent.type==Expose) {
        int width,height;
        x11.window_size(win,width,height);

        viewer.set_size(width,height);

#ifdef EXLIB_NO_GL
        viewer.render();
#else
        if(::glXMakeCurrent(x11.display(),win,x11.context())==False){
          std::cout &lt;&lt; "glXMakeCurrent failed." &lt;&lt; std::endl;
          break;
        }
        viewer.render();
        ::glXSwapBuffers(x11.display(),win);
#endif

      } else if(xevent.type==ButtonPress &amp;&amp; xevent.xbutton.button==1) {
        break;
      }

  }


  x11.delete_window(win);

#ifdef INLIB_MEM
  }inlib::mem::balance(std::cout);
#endif

  return EXIT_SUCCESS;
}
</pre><h1><a class="anchor" id="inexlib_sg_polyhedron"></a>
Boolean operations on solids</h1>
<p>As a curiosity you can have a look to the sg_polyhedron_X11.cpp example that shows a boolean operation over solids. </p><pre class="fragment">    cd &lt;path to exlib&gt;
    cd examples/cpp
    ./build sg_polyhedron_X11.cpp
    Darwin&gt; ./bin_clang/sg_polyhedron_X11
</pre><p> You should see : </p><div class="image">
<img src="exlib_exa_sg_1.png" alt="exlib_exa_sg_1.png"/>
</div>
<p>The code of sg_polyhedron_X11.cpp is similar to the sg_cube_X11 one. We show here only the boolean operation over solids part : </p><pre class="fragment">  #include &lt;exlib/sg/polyhedron&gt;
  ...
  // A Tube with a transvers hole :
  inlib::hep::polyhedronTubs tubs_1(0.7,1.5,2,0,inlib::two_pi());
  inlib::hep::polyhedronTubs tubs_2(  0,0.5,4,0,inlib::two_pi());
  tubs_2.Transform(inlib::rotd(inlib::vec3d(0,1,0),inlib::half_pi()),
                   inlib::vec3d(0,0,0));
  inlib::hep::polyhedron op = tubs_1.subtract(tubs_2);

  exlib::sg::polyhedron* node = new exlib::sg::polyhedron();
  //node-&gt;ph = 
  //  inlib::hep::polyhedronSphere(0.9,1,0,inlib::two_pi(),0,inlib::pi());
  node-&gt;ph = op;
  //node-&gt;solid = false;
  //node-&gt;reduced_wire_frame = false;
  sep-&gt;add(node);
  ...
</pre><h1><a class="anchor" id="inexlib_sg_gui"></a>
GUI done with scene graphs !</h1>
<p>In our apps, in order to have the same look and feel on desktops, phones and tablets, we have decided to handle the GUI by using also OpenGL-ES for the rendering. Then inexlib/sg contains nodes as "button, list" that permit to build a graphical user interface by using the same tools used for the visualization of data.</p>
<p>Obviously, being able to handle a GUI in this way simplifies a lot the situation for Android and iOS since we don't have to coope too much with the problem of mixing java or Obj-C with C++. (The only things that we ask to java on Android is to give us an OpenGL-ES window, and the same with Obj-C on iOS). The drawback is that for the moment our GUIs do not look so great, but at least the functionality is here and it is workable.</p>
<p>As a "button example" you can build sg_button_X11.cpp : </p><pre class="fragment">    cd &lt;path to exlib&gt;
    cd examples/cpp
    ./build sg_button_X11.cpp
    cp ../../data/arialbd.ttf .
    Linux&gt; ./bin_gnu/sg_button_X11
 ( Darwin&gt; ./bin_gnu/sg_button_X11 )
and on Windows :
    ./build sg_button_Windows.cpp
    cygwin&gt; ./bin_visual/sg_button_Windows.exe
</pre><p> You should see : </p><div class="image">
<img src="exlib_exa_sg_button.png" alt="exlib_exa_sg_button.png"/>
</div>
<p> Clicking inside the button should display the message : </p><pre class="fragment">    hello inlib/sg/text_button callback.
</pre><p> You exit the application by clicking the window close button. </p><pre class="fragment">// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file exlib.license for terms.

//exlib_build_use exlib inlib inlib_glutess freetype GL GLX X11

#include &lt;inlib/mem&gt;

#include &lt;inlib/sg/separator&gt;
#include &lt;inlib/sg/ortho&gt;
#include &lt;inlib/sg/matrix&gt;
#include &lt;inlib/sg/color&gt;
#include &lt;inlib/sg/text_button&gt;

#include &lt;exlib/sg/text_freetype&gt;
#include &lt;exlib/sg/viewer&gt;
#include &lt;exlib/X11/session&gt;

#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main(int,char**) {

#ifdef INLIB_MEM
  inlib::mem::set_check_by_class(true);{
#endif

  //////////////////////////////////////////////////////////
  /// create scene graph ///////////////////////////////////
  //////////////////////////////////////////////////////////
  inlib::sg::separator* sep = new inlib::sg::separator;

  inlib::sg::ortho* camera = new inlib::sg::ortho;
  camera-&gt;position.value(inlib::vec3f(0,0,4));    
  camera-&gt;height.value(2);    
  camera-&gt;znear.value(0.1f);
  camera-&gt;zfar.value(100);
  sep-&gt;add(camera);

  inlib::sg::color* color = new inlib::sg::color();
  color-&gt;rgb = inlib::colorf_green();
  sep-&gt;add(color); //sg takes ownership of color.

  exlib::sg::text_freetype ttf;

 {inlib::sg::text_button* b = new inlib::sg::text_button(ttf);
  b-&gt;width = 3;
  b-&gt;height = 1;
  b-&gt;font = inlib::sg::font_arialbd_ttf();
  b-&gt;front_face = inlib::sg::winding_cw;

  b-&gt;back_area::color = inlib::colorf_orange();
  b-&gt;color = inlib::colorf_black();
  b-&gt;arm_color = inlib::colorf_yellow();

  b-&gt;strings.add("click me !");
  b-&gt;confine = true;

  class cbk : public inlib::sg::bcbk {
    typedef inlib::sg::bcbk parent;
  public:
    virtual inlib::sg::return_action action() {
      std::cout &lt;&lt; "hello inlib::sg::text_button callback." &lt;&lt; std::endl;
      return inlib::sg::return_none;     
    }
    virtual inlib::sg::bcbk* copy() const {return new cbk(*this);}
  public:
    cbk():parent(){}
    virtual ~cbk(){}
  private:
    cbk(const cbk&amp; a_from):parent(a_from)/*,m_gv(a_from.m_gv)*/{}
    cbk&amp; operator=(const cbk&amp; a_from){
      parent::operator=(a_from);
      return *this;
    }
  };

  b-&gt;add_callback(new cbk());
  sep-&gt;add(b);}

  //////////////////////////////////////////////////////////
  /// create the viewer, set the scene graph ///////////////
  //////////////////////////////////////////////////////////
  unsigned int ww = 400;
  unsigned int wh = 200;
  
  exlib::sg::viewer viewer(std::cout,ww,wh);
  viewer.sg().add(sep); //give sep ownership to the viewer.

  //////////////////////////////////////////////////////////
  /// create window, attach to the viewer, steer ///////////
  //////////////////////////////////////////////////////////

  exlib::X11::session x11(std::cout);
  if(!x11.display()) return EXIT_FAILURE;

  Window win = x11.create_window("win 1",0,0,ww,wh);
  if(win==0L) return EXIT_FAILURE;
  x11.show_window(win);

  Atom atom = ::XInternAtom(x11.display(),"WM_DELETE_WINDOW",False);

  while(true) { 
      XEvent xevent;
      ::XNextEvent(x11.display(),&amp;xevent);
      //std::cout &lt;&lt; xevent.type &lt;&lt; std::endl;
      //if((xevent.type==Expose)||(xevent.type==ConfigureNotify)) {
      if(xevent.type==ClientMessage) {
        if(xevent.xclient.data.l[0]==(long)atom) break;        
      } else if(xevent.type==Expose) {
        int width,height;
        x11.window_size(win,width,height);

        viewer.set_size(width,height);

        if(::glXMakeCurrent(x11.display(),win,x11.context())==False){
          std::cout &lt;&lt; "glXMakeCurrent failed." &lt;&lt; std::endl;
          break;
        }

        viewer.render();

        ::glXSwapBuffers(x11.display(),win);
        ::glXMakeCurrent(x11.display(),None,NULL);

      } else if(xevent.type==ButtonPress &amp;&amp; xevent.xbutton.button==1) {

        int width,height;
        x11.window_size(win,width,height);

        int x = xevent.xbutton.x;
        int y = height-xevent.xbutton.y;

        float hsize = 2;
        float l = x-hsize; //could be negative.
        float r = x+hsize;
        float b = y-hsize; //could be negative.
        float t = y+hsize;
        inlib::sg::pick_action action(std::cout,width,height,l,r,b,t);
        action.set_stop_at_first(true);

        sep-&gt;pick(action); //can trigger button callback.
        if(!action.end()) {
	  std::cout &lt;&lt; "main :" 
                    &lt;&lt; " bad pick_action end."
                    &lt;&lt; std::endl;
          return EXIT_FAILURE;
        }

        //execute callbacks of picked button :
        inlib::sg::node* node = action.node();
        if(node) {
          if(inlib::sg::base_button* btn = 
             inlib::safe_cast&lt;inlib::sg::node,inlib::sg::base_button&gt;(*node)){
            const std::vector&lt;inlib::sg::bcbk*&gt;&amp; cbks = btn-&gt;cbks().callbacks();
            std::vector&lt;inlib::sg::bcbk*&gt;::const_iterator it;
            for(it=cbks.begin();it!=cbks.end();++it) (*it)-&gt;action();
          }
        }

      }

  }


  x11.delete_window(win);

#ifdef INLIB_MEM
  }inlib::mem::balance(std::cout);
#endif

  return EXIT_SUCCESS;
}
</pre> </div></div><!-- contents -->

</body>
</html>
