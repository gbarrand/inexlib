<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Histogramming</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Histogramming </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The best is to start with an example. So, build and run the inlib histo.cpp example with : </p><pre class="fragment">    cd &lt;path to inlib&gt;
    cd examples/cpp
    c++ -I../.. histo.cpp
    ./a.out
 and on Windows :
    &lt;install VisualC++&gt;
    DOS&gt; &lt;setup VisualC++&gt;
    DOS&gt; CL.exe /I..\.. /GX /GR histo.cpp
    DOS&gt; histo.exe
</pre><p> Simple, straight. And the same with the fit example. In the directory, can be found also a "build" shell script to have less typing : </p><pre class="fragment">    cd &lt;path to inlib&gt;
    cd examples/cpp
    ./build histo.cpp
   (./build -v histo.cpp # to have some traceback)
   (./build -x histo.cpp # to have full shell traceback)
    Linux&gt; ./bin_gnu/histo
    Darwin&gt; ./bin_clang/histo
 and on Windows :
    &lt;install VisualC++&gt;
    &lt;install a minimum of cygwin to have a bash shell&gt;
    DOS&gt; &lt;setup VisualC++&gt;
    DOS&gt; cygwin
 and then proceed as if on a UNIX :
    cd &lt;path to inlib&gt;
    cd examples/cpp
    ./build histo.cpp
    ./bin_visual/histo.exe
</pre><p> Note that the build shell script is done by using bush scripts (see the bush section on the softinex portal for more about bush).</p>
<p>You can have a look to histo.cpp and see that the code is rather simple and easy to customize... </p><pre class="fragment">// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifdef INLIB_MEM
#include &lt;inlib/mem&gt;
#endif //INLIB_MEM

#include &lt;inlib/histo/h1d&gt;
#include &lt;inlib/histo/h2d&gt;
#include &lt;inlib/histo/p1d&gt;
#include &lt;inlib/histo/sliced&gt;

#include &lt;inlib/randd&gt;

#include &lt;iostream&gt;

int main(int argc,char** argv) {
#ifdef INLIB_MEM
  inlib::mem::set_check_by_class(true);{
#endif //INLIB_MEM

  bool print = true;
  if(argc==2) {
    std::string s = argv[1];
    if(s=="-noprint") print = false;
  }

  unsigned int entries = 1000000;

  ////////////////////////////////////////
  /// h1d ////////////////////////////////
  ////////////////////////////////////////
 {
   inlib::rgaussd rg(1,2);
   inlib::histo::h1d h("Gauss",100,-5,5);
   for(unsigned int count=0;count&lt;entries;count++) h.fill(rg.shoot(),1.4);
   if(print) h.hprint(std::cout);
   //std::cout &lt;&lt; " mean " &lt;&lt; h.mean() &lt;&lt; ", rms " &lt;&lt; h.rms() &lt;&lt; std::endl;

   /*
  {unsigned int nbin = h.axis().bins();
   double mn = h.axis().lower_edge();
   double mx = h.axis().upper_edge();}
   */

   // to access all bins data from methods :
  {const std::vector&lt;unsigned int&gt;&amp; _entries = h.bins_entries();
   const std::vector&lt;double&gt;&amp; _bins_sum_w = h.bins_sum_w();
   const std::vector&lt;double&gt;&amp; _bins_sum_w2 = h.bins_sum_w2();
   const std::vector&lt; std::vector&lt;double&gt; &gt;&amp; _bins_sum_xw = h.bins_sum_xw();
   const std::vector&lt; std::vector&lt;double&gt; &gt;&amp; _bins_sum_x2w = h.bins_sum_x2w();
   // dump bin 50 (= in range bin 49) :
   std::cout &lt;&lt; "entries[50] = " &lt;&lt; _entries[50] &lt;&lt; std::endl;
   std::cout &lt;&lt; "  sum_w[50] = " &lt;&lt; _bins_sum_w[50] &lt;&lt; std::endl;
   std::cout &lt;&lt; " sum_w2[50] = " &lt;&lt; _bins_sum_w2[50] &lt;&lt; std::endl;
   std::cout &lt;&lt; " sum_xw[50] = " &lt;&lt; _bins_sum_xw[50][0] &lt;&lt; std::endl;   //0 = xaxis
   std::cout &lt;&lt; "sum_x2w[50] = " &lt;&lt; _bins_sum_x2w[50][0] &lt;&lt; std::endl;  //0 = xaxis
   }

   // to get all internal data of an histo :
  {const inlib::histo::h1d::hd_t&amp; hdata = h.dac();  //dac=data access.
   const std::vector&lt;unsigned int&gt;&amp; _entries = hdata.m_bin_entries;
   const std::vector&lt;double&gt;&amp; _bins_sum_w = hdata.m_bin_Sw;
   const std::vector&lt;double&gt;&amp; _bins_sum_w2 = hdata.m_bin_Sw2;
   const std::vector&lt; std::vector&lt;double&gt; &gt;&amp; _bins_sum_xw = hdata.m_bin_Sxw;
   const std::vector&lt; std::vector&lt;double&gt; &gt;&amp; _bins_sum_x2w = hdata.m_bin_Sx2w;
   // dump bin 50 :
   std::cout &lt;&lt; "entries[50] = " &lt;&lt; _entries[50] &lt;&lt; std::endl;
   std::cout &lt;&lt; "  sum_w[50] = " &lt;&lt; _bins_sum_w[50] &lt;&lt; std::endl;
   std::cout &lt;&lt; " sum_w2[50] = " &lt;&lt; _bins_sum_w2[50] &lt;&lt; std::endl;
   std::cout &lt;&lt; " sum_xw[50] = " &lt;&lt; _bins_sum_xw[50][0] &lt;&lt; std::endl;   //0 = xaxis
   std::cout &lt;&lt; "sum_x2w[50] = " &lt;&lt; _bins_sum_x2w[50][0] &lt;&lt; std::endl;  //0 = xaxis
  }   
   // change in range bin 49 weight :
  {std::cout &lt;&lt; "bin_Sw(49) = " &lt;&lt; h.bin_Sw(49) &lt;&lt; std::endl;   
   inlib::histo::h1d::hd_t hdata = h.dac();  //dac=data access.
   hdata.m_bin_Sw[50] *= 2;
   h.copy_from_data(hdata);
   std::cout &lt;&lt; "modified(*2) bin_Sw(49) = " &lt;&lt; h.bin_Sw(49) &lt;&lt; std::endl;   
  }
  
 }

 {
   inlib::rbwd rbw(0,1);
   inlib::histo::h1d h("BW",100,-5,5);
   for(unsigned int count=0;count&lt;entries;count++) h.fill(rbw.shoot(),2.3);
   if(print) h.hprint(std::cout);
 }

  ////////////////////////////////////////
  /// p1d ////////////////////////////////
  ////////////////////////////////////////
 {
   inlib::rgaussd rg(1,2);
   inlib::rbwd rbw(0,1);
   inlib::histo::p1d h("Profile",100,-5,5,-2,2);
   for(unsigned int count=0;count&lt;entries;count++) {
     h.fill(rg.shoot(),rbw.shoot(),1);
   }
   if(print) h.hprint(std::cout);

   // to get all internal data :
   typedef inlib::histo::profile_data&lt;double,unsigned int,unsigned int,double,double&gt; pd_t;
   pd_t hdata = h.get_histo_data(); 
 }

  ////////////////////////////////////////
  /// h2d ////////////////////////////////
  ////////////////////////////////////////
 {
   inlib::rgaussd rg(1,2);
   inlib::rbwd rbw(0,1);
   inlib::histo::h2d h("Gauss_BW",100,-5,5,100,-2,2);
   for(unsigned int count=0;count&lt;entries;count++) h.fill(rg.shoot(),rbw.shoot(),0.8);
   if(print) h.hprint(std::cout);

   if(print){
     std::cout &lt;&lt; "x mean " &lt;&lt; h.mean_x()
               &lt;&lt; " rms " &lt;&lt; h.rms_x() &lt;&lt; std::endl;
     std::cout &lt;&lt; "y mean " &lt;&lt; h.mean_y()
               &lt;&lt; " rms " &lt;&lt; h.rms_y() &lt;&lt; std::endl;
   }

   /*
  {unsigned int nbin = h.axis_x().bins();
   double mn = h.axis_x().lower_edge();
   double mx = h.axis_x().upper_edge();}

  {unsigned int nbin = h.axis_y().bins();
   double mn = h.axis_y().lower_edge();
   double mx = h.axis_y().upper_edge();}
   */

  {
    inlib::histo::h1d* projection = inlib::histo::projection_x(h,"ProjX");
    if(!projection) return -1;
    projection-&gt;set_title("Gauss_BW_projectionX");
    if(print) projection-&gt;hprint(std::cout);
    delete projection;
  }
   
  {
    inlib::histo::h1d* projection = inlib::histo::projection_y(h,"ProjY");
    if(!projection) return -1;
    projection-&gt;set_title("Gauss_BW_projectionY");
    if(print) projection-&gt;hprint(std::cout);
    delete projection;
  }

  {
    inlib::histo::h1d* slice = inlib::histo::slice_x(h,40,60,"SliceX");
    if(!slice) return -1;
    slice-&gt;set_title("Gauss_BW_sliceX");
    if(print) slice-&gt;hprint(std::cout);
    delete slice;
  }

  typedef inlib::histo::axis&lt;double,unsigned int&gt; axis_t;
  {
    inlib::histo::h1d* slice = inlib::histo::slice_x(h,axis_t::UNDERFLOW_BIN,axis_t::UNDERFLOW_BIN,"SliceX");
    if(!slice) return -1;
    slice-&gt;set_title("Gauss_BW_sliceX_UNDER");
    if(print) slice-&gt;hprint(std::cout);
    delete slice;
  }

  {
    inlib::histo::h1d* slice = inlib::histo::slice_x(h,axis_t::OVERFLOW_BIN,axis_t::OVERFLOW_BIN,"SliceX");
    if(!slice) return -1;
    slice-&gt;set_title("Gauss_BW_sliceX_OVER");
    if(print) slice-&gt;hprint(std::cout);
    delete slice;
  }

  {
    inlib::histo::h1d* slice = inlib::histo::slice_y(h,30,50,"SliceY");
    if(!slice) return -1;
    slice-&gt;set_title("Gauss_BW_sliceY");
    if(print) slice-&gt;hprint(std::cout);
    delete slice;
  }

  {
    using namespace inlib::histo; //playing with namespaces.
    h1d* slice = slice_y(h,axis_t::UNDERFLOW_BIN,axis_t::UNDERFLOW_BIN,"SliceY");
    if(!slice) return -1;
    slice-&gt;set_title("Gauss_BW_sliceY_UNDER");
    if(print) slice-&gt;hprint(std::cout);
    delete slice;
  }

  {
    namespace my_histo = inlib::histo; //playing with namespaces.
    my_histo::h1d* slice = slice_y(h,inlib::histo::axis_OVERFLOW_BIN,inlib::histo::axis_OVERFLOW_BIN,"SliceY");
    if(!slice) return -1;
    slice-&gt;set_title("Gauss_BW_sliceY_OVER");
    if(print) slice-&gt;hprint(std::cout);
    delete slice;
  }

  {
    inlib::histo::p1d* projection = inlib::histo::profile_x(h,"ProfileX");
    if(!projection) return -1;
    projection-&gt;set_title("Gauss_BW_profileX");
    if(print) projection-&gt;hprint(std::cout);
    delete projection;
  }

  {
    inlib::histo::p1d* projection = inlib::histo::profile_y(h,"ProfileY");
    if(!projection) return -1;
    projection-&gt;set_title("Gauss_BW_profileY");
    if(print) projection-&gt;hprint(std::cout);
    delete projection;
  }

 }

  ////////////////////////////////////////
  /// h3d ////////////////////////////////
  ////////////////////////////////////////
 {
   inlib::rgaussd rg(1,2);
   inlib::rbwd rbw(0,1);
   inlib::rtausmed rflat;
   inlib::histo::h3d h("Gauss_BW_flat",100,-10,10,100,-2,2,100,-2,2);
   for(unsigned int count=0;count&lt;entries;count++) {
     h.fill(rg.shoot(),rbw.shoot(),rflat.shoot());
   }
   if(print) h.hprint(std::cout);

   if(print){
     std::cout &lt;&lt; "x mean " &lt;&lt; h.mean_x()
               &lt;&lt; " rms " &lt;&lt; h.rms_x() &lt;&lt; std::endl;
     std::cout &lt;&lt; "y mean " &lt;&lt; h.mean_y()
               &lt;&lt; " rms " &lt;&lt; h.rms_y() &lt;&lt; std::endl;
     std::cout &lt;&lt; "z mean " &lt;&lt; h.mean_z()
               &lt;&lt; " rms " &lt;&lt; h.rms_z() &lt;&lt; std::endl;
   }

  {
    inlib::histo::h2d* projection = inlib::histo::projection_xy(h,"ProjXY");
    if(!projection) return -1;
    projection-&gt;set_title("Gauss_BW_flat_projectionXY");
    if(print) projection-&gt;hprint(std::cout);
    
   {inlib::histo::h1d* _projection =
      inlib::histo::projection_x(*projection,"ProjX");
    if(!_projection) return -1;
    _projection-&gt;set_title("Gauss_BW_flat_projectionX");
    if(print) _projection-&gt;hprint(std::cout);
    delete _projection;}

   {inlib::histo::h1d* _projection =
      inlib::histo::projection_y(*projection,"ProjY");
    if(!_projection) return -1;
    _projection-&gt;set_title("Gauss_BW_flat_projectionY");
    if(print) _projection-&gt;hprint(std::cout);
    delete _projection;}

    delete projection;
  }
   
  {
    inlib::histo::h2d* projection = inlib::histo::projection_yz(h,"ProjYZ");
    if(!projection) return -1;
    projection-&gt;set_title("Gauss_BW_flat_projectionYZ");
    if(print) projection-&gt;hprint(std::cout);
    
   {inlib::histo::h1d* _projection =
      inlib::histo::projection_y(*projection,"ProjZ");
    if(!_projection) return -1;
    _projection-&gt;set_title("Gauss_BW_flat_projectionZ");
    if(print) _projection-&gt;hprint(std::cout);
    delete _projection;}

    delete projection;
  }
   
 }

  //////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////

#ifdef INLIB_MEM
  }inlib::mem::balance(std::cout);
#endif //INLIB_MEM

  return 0;
}
</pre> </div></div><!-- contents -->

</body>
</html>
